# AlgoVIz
AlgoViz is an interactive visualizer for major algorithms. It provides visual representations of sorting, pathfinding, and searching algorithms, helping users to better understand how these algorithms work step-by-step.
It is deployed at : https://mr-bansal.github.io/AlgoViz/

# Features
Visualizes popular sorting algorithms including Merge Sort, Bubble Sort, Insertion Sort, and Quick Sort.
Visualizes Pathfinding algorithms such as Breadth-First Search (BFS), Depth-First Search (DFS), Dijkstra's Algorithm, Best First Search, and A* Search.
Visualizes Searching algorithms like Linear Search, Binary Search, Jump Search, and Exponential Search.


# Sections

# Sorting Algorithms
This section includes visualizations for the following sorting algorithms:

Merge Sort: A divide-and-conquer algorithm that splits the array into halves recursively sorts them and merges the sorted halves.

Bubble Sort: A simple comparison-based algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

Insertion Sort: Builds the sorted array one element at a time by repeatedly taking the next element and inserting it into the correct position.

Quick Sort: A divide-and-conquer algorithm that selects a pivot element and partitions the array into two sub-arrays, which are then sorted independently.


# Pathfinding Algorithms
This section includes visualizations for the following pathfinding algorithms:

Breadth-First Search (BFS): Explores all the neighbour nodes at the present depth before moving on to nodes at the next depth level.

Depth-First Search (DFS): Explores each branch as far as possible before backtracking.

Dijkstra's Algorithm: Finds the shortest path from the source node to all other nodes in a graph with non-negative edge weights.

Best First Search: Explores a graph by selecting the most promising node according to a specified rule.

A* Search: A graph traversal and path search algorithm that uses heuristics to find the shortest path from a start node to a goal node.



# Searching Algorithms
This section includes visualizations for the following searching algorithms:

Linear Search: Sequentially checks each element of the list until the target value is found.

Binary Search: Finds the position of a target value within a sorted array by repeatedly dividing the search interval in half.

Jump Search: Divide the list into blocks and search for the target block before performing a linear search within the block.

Exponential Search: Finds the range where the target element is located and then performs a binary search within that range.



# Contributing
Contributions are welcome! If you have suggestions for new features or improvements, feel free to create an issue or submit a pull request.


# License
This project is licensed under the MIT License.
